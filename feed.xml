<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="https://smyeong123.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://smyeong123.github.io/" rel="alternate" type="text/html" /><updated>2025-05-16T00:43:07+00:00</updated><id>https://smyeong123.github.io/feed.xml</id><title type="html">smyeong123</title><subtitle>I am a Bachelor of Science graduate at the University of Sydney, majoring in Computer Science with a minor in Software Development.  My interests include backend development in Java, as well as artificial intelligence, particularly in natural language processing (NLP), computer vision (CV), and multimodal learning.
</subtitle><author><name>Sangmyeong Lee</name></author><entry><title type="html">[EN] Linear Algebra Interview Prep</title><link href="https://smyeong123.github.io/2025/03/10/Linear-Algebra.html" rel="alternate" type="text/html" title="[EN] Linear Algebra Interview Prep" /><published>2025-03-10T00:00:00+00:00</published><updated>2025-03-10T00:00:00+00:00</updated><id>https://smyeong123.github.io/2025/03/10/Linear-Algebra</id><content type="html" xml:base="https://smyeong123.github.io/2025/03/10/Linear-Algebra.html"><![CDATA[<h1 id="linear-algebra">Linear Algebra</h1>

<p>We are going to revise Linear Algebra assuming you had learnt it before.
This note aims to cover the concepts that may appear in the technical interview.</p>

<h2 id="what-is-basis-of-a-vector">What is basis of a vector?</h2>

<p>A <strong>basis</strong> of a vector space is a set of linearly independent vectors that span the entire space. Any vector in the space can be expressed as a unique linear combination of basis vectors.</p>

<p>For example, in \(\mathbb{R}^2\) the standard basis is:</p>

\[\mathbf{e}_1 = \begin{bmatrix}1 \\ 0\end{bmatrix}, \quad \mathbf{e}_2 = \begin{bmatrix}0 \\ 1\end{bmatrix}\]

<h2 id="what-is-unit-vector">What is unit vector?</h2>

<p>A <strong>unit vector</strong> is a vector with a magnitude (or length) of 1.</p>

<p>If \(\vec{v}\) is a vector, then the unit vector \(\hat{v}\) in the direction of \(\vec{v}\) is:</p>

\[\hat{v} = \frac{\vec{v}}{\|\vec{v}\|}\]

<h2 id="what-is-span-of-vector">What is span of vector?</h2>

<p>The <strong>span</strong> of a set of vectors is the set of all linear combinations of those vectors.</p>

<p>If \(\vec{v}_1, \vec{v}_2, \dots, \vec{v}_n\) are vectors, then:</p>

\[\text{span}(\vec{v}_1, \dots, \vec{v}_n) = \left\{ \sum_{i=1}^n a_i \vec{v}_i \mid a_i \in \mathbb{R} \right\}\]

<h2 id="what-is-linearly-dependent">What is linearly dependent?</h2>

<p>Vectors are <strong>linearly dependent</strong> if at least one of them can be written as a linear combination of the others.</p>

<p>Formally, vectors \(\vec{v}_1, \dots, \vec{v}_n\) are linearly dependent if</p>

\[\exists \; a_1, \dots, a_n \text{ not all zero, such that } \sum_{i=1}^n a_i \vec{v}_i = 0\]

<h2 id="what-is-the-vector-space">What is the vector space?</h2>

<p>A <strong>vector space</strong> is a collection of vectors that can be added together and multiplied by scalars, satisfying the axioms of vector addition and scalar multiplication.</p>

<p>Examples include \(\mathbb{R}^n\), the set of all nn-dimensional real vectors.</p>

<h2 id="what-is-rank-of-a-matrix">What is rank of a matrix?</h2>

<p>The <strong>rank</strong> of a matrix is the dimension of its column space (or row space).</p>

<p>It equals the number of linearly independent columns (or rows).</p>

<h2 id="what-are-eigenvector-and-eigenvalue">What are eigenvector and eigenvalue?</h2>

<p>Given a square matrix \(A\), a non-zero vector \(\vec{v}\) is an <strong>eigenvector</strong> of \(A\) if:</p>

\[A\vec{v} = \lambda \vec{v}\]

<p>for some scalar \(\lambda\), which is called the <strong>eigenvalue</strong> corresponding to \(\vec{v}\).</p>

<h2 id="what-is-the-transpose-of-a-matrix">What is the transpose of a matrix?</h2>

<p>The <strong>transpose</strong> of a matrix \(A\) is obtained by flipping rows and columns.</p>

<p>If \(A = [a_{ij}]\) , then the transpose \(A^T\) is:</p>

\[A^T = [a_{ji}]\]

<h2 id="what-is-pca-and-how-to-compute-it">What is PCA and how to compute it?</h2>

<p><strong>Principal Component Analysis (PCA)</strong> is a technique to reduce the dimensionality of data while retaining the most variance.</p>

<p>Steps to compute PCA:</p>

<ol>
  <li>Standardise the data.</li>
  <li>Compute the covariance matrix \(\Sigma\).</li>
  <li>Perform eigen-decomposition on \(\Sigma\).</li>
  <li>Project data onto the top \(k\) eigenvectors (principal components).</li>
</ol>

<h2 id="what-is-svd-singular-value-decomposition-and-when-do-i-use-it">What is SVD (Singular Value Decomposition) and when do I use it?</h2>

<p><strong>Singular Value Decomposition (SVD)</strong> factorizes any matrix \(A \in \mathbb{R}^{m \times n}\) into three matrices:</p>

\[A = U \Sigma V^T\]

<p>Where: 1. \(U\) is an \(mxm\) orthogonal matrix, 2. \(\Sigma\) is an \(mxn\) diagonal matrix with singular values 3. \(V\) is an \(nxn\) orthogonal matrix.</p>

<p><strong>SVD is used for:</strong></p>

<ul>
  <li>Dimensionality reduction,</li>
  <li>Noise reduction,</li>
  <li>Solving linear systems,</li>
  <li>Data compression.</li>
</ul>

<h2 id="what-does-the-determinant-of-a-matrix-tell-you">What does the determinant of a matrix tell you?</h2>

<p>The <strong>determinant</strong> of a square matrix tells you:</p>

<ul>
  <li>Whether the matrix is <strong>invertible</strong>: \(\det(A) \ne 0\) means invertible, \(\det(A) = 0\) means singular.</li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>How the matrix <strong>scales volume</strong>: $$</td>
          <td>\det(A)</td>
          <td>$$ is the volume scaling factor.</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>Whether the transformation <strong>preserves orientation</strong>: sign of the determinant matters.</li>
  <li>Whether the rows/columns are <strong>linearly independent</strong>: if not, the determinant is zero.</li>
</ul>

<h2 id="example-determinant-is-zero-if-columns-are-dependent">Example: Determinant is Zero if Columns Are Dependent</h2>

<p>Let:</p>

\[\begin{bmatrix}
1 &amp; 2 &amp; 3 \\
4 &amp; 8 &amp; 5 \\
7 &amp; 14 &amp; 6 \\
\end{bmatrix}\]

<p>Here, Column 2 is two times of Column 1, so Columns 1 and 2 are linearly dependent.</p>

<p>Using cofactor expansion:</p>

\[\begin{align*}
\det(A) = 1 \cdot \left| \begin{array}{cc} 8 &amp; 5 \\ 14 &amp; 6 \end{array} \right|
- 2 \cdot \left| \begin{array}{cc} 4 &amp; 5 \\ 7 &amp; 6 \end{array} \right|
+ 3 \cdot \left| \begin{array}{cc} 4 &amp; 8 \\ 7 &amp; 14 \end{array} \right| \\
= 1(-22) - 2(-11) + 3(0) \\
= -22 + 22 + 0 = 0
\end{align*}\]

<p>Thus, \(\det(A) = 0\).</p>]]></content><author><name>Sangmyeong Lee</name></author><category term="CS" /><summary type="html"><![CDATA[Linear Algebra We are going to revise Linear Algebra assuming you had learnt it before. This note aims to cover the concepts that may appear in the technical interview. What is basis of a vector? A basis of a vector space is a set of linearly independent vectors that span the entire space. Any vector in the space can be expressed as a unique linear combination of basis vectors. For example, in \(\mathbb{R}^2\) the standard basis is: \[\mathbf{e}_1 = \begin{bmatrix}1 \\ 0\end{bmatrix}, \quad \mathbf{e}_2 = \begin{bmatrix}0 \\ 1\end{bmatrix}\] What is unit vector? A unit vector is a vector with a magnitude (or length) of 1. If \(\vec{v}\) is a vector, then the unit vector \(\hat{v}\) in the direction of \(\vec{v}\) is: \[\hat{v} = \frac{\vec{v}}{\|\vec{v}\|}\] What is span of vector? The span of a set of vectors is the set of all linear combinations of those vectors. If \(\vec{v}_1, \vec{v}_2, \dots, \vec{v}_n\) are vectors, then: \[\text{span}(\vec{v}_1, \dots, \vec{v}_n) = \left\{ \sum_{i=1}^n a_i \vec{v}_i \mid a_i \in \mathbb{R} \right\}\] What is linearly dependent? Vectors are linearly dependent if at least one of them can be written as a linear combination of the others. Formally, vectors \(\vec{v}_1, \dots, \vec{v}_n\) are linearly dependent if \[\exists \; a_1, \dots, a_n \text{ not all zero, such that } \sum_{i=1}^n a_i \vec{v}_i = 0\] What is the vector space? A vector space is a collection of vectors that can be added together and multiplied by scalars, satisfying the axioms of vector addition and scalar multiplication. Examples include \(\mathbb{R}^n\), the set of all nn-dimensional real vectors. What is rank of a matrix? The rank of a matrix is the dimension of its column space (or row space). It equals the number of linearly independent columns (or rows). What are eigenvector and eigenvalue? Given a square matrix \(A\), a non-zero vector \(\vec{v}\) is an eigenvector of \(A\) if: \[A\vec{v} = \lambda \vec{v}\] for some scalar \(\lambda\), which is called the eigenvalue corresponding to \(\vec{v}\). What is the transpose of a matrix? The transpose of a matrix \(A\) is obtained by flipping rows and columns. If \(A = [a_{ij}]\) , then the transpose \(A^T\) is: \[A^T = [a_{ji}]\] What is PCA and how to compute it? Principal Component Analysis (PCA) is a technique to reduce the dimensionality of data while retaining the most variance. Steps to compute PCA: Standardise the data. Compute the covariance matrix \(\Sigma\). Perform eigen-decomposition on \(\Sigma\). Project data onto the top \(k\) eigenvectors (principal components). What is SVD (Singular Value Decomposition) and when do I use it? Singular Value Decomposition (SVD) factorizes any matrix \(A \in \mathbb{R}^{m \times n}\) into three matrices: \[A = U \Sigma V^T\] Where: 1. \(U\) is an \(mxm\) orthogonal matrix, 2. \(\Sigma\) is an \(mxn\) diagonal matrix with singular values 3. \(V\) is an \(nxn\) orthogonal matrix. SVD is used for: Dimensionality reduction, Noise reduction, Solving linear systems, Data compression. What does the determinant of a matrix tell you? The determinant of a square matrix tells you: Whether the matrix is invertible: \(\det(A) \ne 0\) means invertible, \(\det(A) = 0\) means singular. How the matrix scales volume: $$ \det(A) $$ is the volume scaling factor. Whether the transformation preserves orientation: sign of the determinant matters. Whether the rows/columns are linearly independent: if not, the determinant is zero. Example: Determinant is Zero if Columns Are Dependent Let: \[\begin{bmatrix} 1 &amp; 2 &amp; 3 \\ 4 &amp; 8 &amp; 5 \\ 7 &amp; 14 &amp; 6 \\ \end{bmatrix}\] Here, Column 2 is two times of Column 1, so Columns 1 and 2 are linearly dependent. Using cofactor expansion: \[\begin{align*} \det(A) = 1 \cdot \left| \begin{array}{cc} 8 &amp; 5 \\ 14 &amp; 6 \end{array} \right| - 2 \cdot \left| \begin{array}{cc} 4 &amp; 5 \\ 7 &amp; 6 \end{array} \right| + 3 \cdot \left| \begin{array}{cc} 4 &amp; 8 \\ 7 &amp; 14 \end{array} \right| \\ = 1(-22) - 2(-11) + 3(0) \\ = -22 + 22 + 0 = 0 \end{align*}\] Thus, \(\det(A) = 0\).]]></summary></entry><entry><title type="html">[KR] 백준 14003 - 가장 긴 증가하는 부분 수열 5</title><link href="https://smyeong123.github.io/2025/02/01/14003-solution.html" rel="alternate" type="text/html" title="[KR] 백준 14003 - 가장 긴 증가하는 부분 수열 5" /><published>2025-02-01T00:00:00+00:00</published><updated>2025-02-01T00:00:00+00:00</updated><id>https://smyeong123.github.io/2025/02/01/14003-solution</id><content type="html" xml:base="https://smyeong123.github.io/2025/02/01/14003-solution.html"><![CDATA[<h1 id="백준-14003---가장-긴-증가하는-부분-수열-5">백준 14003 - 가장 긴 증가하는 부분 수열 5</h1>

<blockquote>
  <p>이글을 읽으면 LIS(Longest Increasing Sequence) 알고리즘을 이해 할 수 있고 관련 문제를 풀 수 있습니다.</p>
</blockquote>

<h2 id="문제-리스트">문제 리스트</h2>

<ul>
  <li><a href="https://www.acmicpc.net/problem/11053">가장 큰 증가하는 부분 수열 - 11053</a></li>
  <li><a href="https://www.acmicpc.net/problem/11055">가장 큰 증가하는 부분 수열 - 11055</a></li>
  <li><a href="https://www.acmicpc.net/problem/12015">가장 긴 증가하는 부분 수열 2 - 12015</a></li>
  <li><a href="https://www.acmicpc.net/problem/14003">가장 긴 증가하는 부분 수열 5 - 14003</a></li>
</ul>

<h2 id="문제-설명">문제 설명</h2>

<p>수열 \(X\)가 주어졌을때 가장 긴 증가하는 부분 수열을 구하는 문제 입니다.
입력으로 \(X = [10, 20, 10, 30, 20, 50]\)가 주어졌을때 가장 긴 증가하는 부분을 굵게 표현하자면 다음과 같습니다. \(A\) = {<strong>10</strong>, <strong>20</strong>, 10, <strong>30</strong>, 20, <strong>50</strong>} 그러므로, 출력이 되어야 하는것은 최대 길이인 4와 \(10, 20, 30, 50\)입니다.</p>

<h2 id="문제-풀이">문제 풀이</h2>

<h3 id="dpmemoization--double-loop">DP(Memoization) + Double Loop</h3>

<p>가장 쉬운 풀이 방법은 메모이제이션 방법과 이중 루프를 이용해 푸는 방법입니다. 11053풀이는 \(N\) 길이로 모든 \(dp\) 원소를 1으로 초기화 합니다. 여기서 \(dp[i]\)는 \(i\)번째 원소를 마지막으로 한 LIS의 길이를 저장합니다.</p>

<p>그 다음 각 \(i\)번쨰 원소에서 전에 발생한 \(j\)번째 원소들을 순회 하면서 다음과 같은 점화식을 실행해 \(dp[i] = max(dp[i], dp[j] + 1)\text{, where }0&lt;j&lt;i\), 가장 큰 증가하는 부분 수열의 길이를 구할 수 있습니다. 이 이중 루프의 실제 연산 횟수는 \(\frac{N(N-1)}{2}\) 과 같으므로, \(O(\frac{N(N-1)}{2}) = O(N^2)\)입니다.</p>

<h3 id="binary-search--traceback">Binary Search + Traceback</h3>

<p>이제 더 효율적인 방법으로 문제를 풀어보겠습니다. 이 방법은 이분탐색과 역추적(traceback)을 활용해서 푸는 방법으로 크게 두가지로 나눌 수 있습니다.
우선 <code class="language-plaintext highlighter-rouge">dp</code> 배열을 사용해 길이별 증가 수열의 최소 마지막 값을 추적합니다.
즉, <code class="language-plaintext highlighter-rouge">dp[i]</code>는 길이 \(i+1\)인 수열 중에서 가장 마지막 값이 가장 작은 수를 의미합니다.</p>

<p>이 과정을 통해 \(O(N log N)\) 시간 내에 LIS 길이를 구할 수 있고,
동시에 position[i] 배열을 만들어 각 원소가 몇 번째 길이에 해당하는 수인지 기록합니다.</p>

<p>LIS 길이를 구한 후, 원래 수열을 뒤에서부터 탐색하면서 다음 조건을 만족하는 원소를 찾습니다:</p>

<p><code class="language-plaintext highlighter-rouge">position[i]</code> == <code class="language-plaintext highlighter-rouge">현재 기대하는 길이 - 1</code></p>

<p>예를 들어 LIS의 길이가 4라면, 우리는 다음과 같이 찾습니다:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>position[i] == 3

position[i] == 2

position[i] == 1

position[i] == 0
</code></pre></div></div>

<p>이렇게 뒤에서부터 찾아서 리스트에 추가하면, 수열이 거꾸로 저장되므로 마지막에 reverse()를 해주면 실제 LIS를 얻을 수 있습니다.</p>

<blockquote>
  <p>그러면 왜 뒤에서 부터 찾을까요?</p>
</blockquote>

<p>LIS는 단순히 수만 증가하는 게 아니라, 인덱스 조건도 만족해야 합니다:</p>

<p>\(i &lt; j\) 이면서 <code class="language-plaintext highlighter-rouge">X[i]</code> &lt; <code class="language-plaintext highlighter-rouge">X[j]</code></p>

<p>앞에서부터 탐색하면 이미 선택한 값보다 작은 값을 다시 고를 가능성이 생기기 때문에,
뒤에서부터 길이에 맞는 값을 하나씩 선택하는 게 가장 안전한 방식입니다.</p>

<h2 id="예제-입력">예제 입력</h2>

<p>예시로 입력이 <code class="language-plaintext highlighter-rouge">N = 8, X = 5 7 3 8 4 9 2 6</code>으로 주어지면 다음과 같은 방법으로 <code class="language-plaintext highlighter-rouge">dp</code>와 <code class="language-plaintext highlighter-rouge">position</code>이 구해지고</p>

<table>
  <thead>
    <tr>
      <th>i</th>
      <th>X[i]</th>
      <th>dp (before)</th>
      <th>lower_bound(dp, X[i])</th>
      <th>dp (after)</th>
      <th>position[i]</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</td>
      <td>5</td>
      <td>[]</td>
      <td>0</td>
      <td>[5]</td>
      <td>0</td>
    </tr>
    <tr>
      <td>1</td>
      <td>7</td>
      <td>[5]</td>
      <td>1</td>
      <td>[5, 7]</td>
      <td>1</td>
    </tr>
    <tr>
      <td>2</td>
      <td>3</td>
      <td>[5, 7]</td>
      <td>0</td>
      <td>[3, 7]</td>
      <td>0</td>
    </tr>
    <tr>
      <td>3</td>
      <td>8</td>
      <td>[3, 7]</td>
      <td>2</td>
      <td>[3, 7, 8]</td>
      <td>2</td>
    </tr>
    <tr>
      <td>4</td>
      <td>4</td>
      <td>[3, 7, 8]</td>
      <td>1</td>
      <td>[3, 4, 8]</td>
      <td>1</td>
    </tr>
    <tr>
      <td>5</td>
      <td>9</td>
      <td>[3, 4, 8]</td>
      <td>3</td>
      <td>[3, 4, 8, 9]</td>
      <td>3</td>
    </tr>
    <tr>
      <td>6</td>
      <td>2</td>
      <td>[3, 4, 8, 9]</td>
      <td>0</td>
      <td>[2, 4, 8, 9]</td>
      <td>0</td>
    </tr>
    <tr>
      <td>7</td>
      <td>6</td>
      <td>[2, 4, 8, 9]</td>
      <td>2</td>
      <td>[2, 4, 6, 9]</td>
      <td>2</td>
    </tr>
  </tbody>
</table>

<p>역순으로 X를 탐색하면서 position의 값이 <code class="language-plaintext highlighter-rouge">len(dp)-1</code> 에서 0까지 작아지는 순서로 X의 원소를 찾아 넣어줍니다. 그러면 \([9,8,7,5]\)가 나오는데, 이를 뒤집어 출력합니다.</p>

<h2 id="소스-코드">소스 코드</h2>

<p>\(O(N^2)\) 풀이 방법</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># given we got N,X from the input
</span><span class="n">dp</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">N</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">X</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">dp</span><span class="p">))</span>
</code></pre></div></div>

<p>\(O(Nlog(N))\) 풀이 방법</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># given we got N,X from the input
</span>
<span class="k">def</span> <span class="nf">lower_bound</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
    <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">:</span>
        <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">target</span><span class="p">:</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span>
    <span class="k">return</span> <span class="n">left</span>

<span class="n">dp</span><span class="p">,</span> <span class="n">position</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">N</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">lower_bound</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">dp</span><span class="p">):</span>
        <span class="n">dp</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dp</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>
    <span class="n">position</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span>

<span class="n">lis</span><span class="p">,</span> <span class="n">length</span> <span class="o">=</span> <span class="p">[],</span> <span class="nb">len</span><span class="p">(</span><span class="n">dp</span><span class="p">)</span>
<span class="n">current_length</span> <span class="o">=</span> <span class="n">length</span> <span class="o">-</span> <span class="mi">1</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">position</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">current_length</span><span class="p">:</span>
        <span class="n">lis</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">current_length</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">current_length</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">break</span>

<span class="k">print</span><span class="p">(</span><span class="n">length</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="o">*</span><span class="nb">reversed</span><span class="p">(</span><span class="n">lis</span><span class="p">))</span>
</code></pre></div></div>]]></content><author><name>Sangmyeong Lee</name></author><category term="PS" /><category term="DP" /><category term="LIS" /><summary type="html"><![CDATA[백준 14003 - 가장 긴 증가하는 부분 수열 5]]></summary></entry><entry><title type="html">[KR] 백준 9935 - 문자열 폭발</title><link href="https://smyeong123.github.io/2025/01/18/9935-solution.html" rel="alternate" type="text/html" title="[KR] 백준 9935 - 문자열 폭발" /><published>2025-01-18T00:00:00+00:00</published><updated>2025-01-18T00:00:00+00:00</updated><id>https://smyeong123.github.io/2025/01/18/9935-solution</id><content type="html" xml:base="https://smyeong123.github.io/2025/01/18/9935-solution.html"><![CDATA[<h1 id="백준-9935---문자열-폭발">백준 9935 - 문자열 폭발</h1>
<h2 id="문제-설명">문제 설명</h2>

<p>주어진 문자열 <code class="language-plaintext highlighter-rouge">og_str</code>에서 특정 폭발 문자열 <code class="language-plaintext highlighter-rouge">explosive_str</code>을 찾아 제거하는 과정을 반복하여 최종적으로 남는 문자열을 구하는 문제입니다. 만약 모든 문자가 제거된다면 “FRULA”를 출력합니다.</p>

<h2 id="문제-풀이">문제 풀이</h2>

<ol>
  <li><strong>입력 처리</strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">sys.stdin.readline()</code>을 사용하여 문자열을 입력받고, 개행 문자를 제거합니다.</li>
      <li><code class="language-plaintext highlighter-rouge">og_str</code>을 리스트로 변환하여 한 글자씩 접근할 수 있도록 합니다.</li>
      <li><code class="language-plaintext highlighter-rouge">explosive_str</code>은 문자열 그대로 저장합니다.</li>
    </ul>
  </li>
  <li><strong>스택을 활용한 폭발 문자열 제거</strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">parsed_str</code> 리스트를 스택처럼 사용하여 하나씩 문자를 추가합니다.</li>
      <li><code class="language-plaintext highlighter-rouge">parsed_str</code>의 마지막 <code class="language-plaintext highlighter-rouge">len(explosive_str)</code> 만큼을 확인하여 <code class="language-plaintext highlighter-rouge">explosive_str</code>과 동일하면 폭발시킵니다.</li>
      <li>문자열을 직접 조작하는 것보다 리스트에서 <code class="language-plaintext highlighter-rouge">pop()</code> 연산을 수행하는 것이 더 효율적이므로 이 방법을 사용합니다.</li>
    </ul>
  </li>
  <li><strong>결과 출력</strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">parsed_str</code>에 남아 있는 문자가 있다면 이를 합쳐 출력하고, 없다면 “FRULA”를 출력합니다.</li>
    </ul>
  </li>
</ol>

<h2 id="시간-복잡도-분석">시간 복잡도 분석</h2>

<ul>
  <li>입력 문자열의 길이를 <code class="language-plaintext highlighter-rouge">N</code>, 폭발 문자열의 길이를 <code class="language-plaintext highlighter-rouge">M</code>이라고 하면, 최악의 경우 모든 문자를 한 번씩 추가하고 폭발 문자열과 비교하는 과정이 반복됩니다.</li>
  <li><code class="language-plaintext highlighter-rouge">''.join(parsed_str[-token_len:])</code>을 이용한 비교 연산이 O(M)이고, <code class="language-plaintext highlighter-rouge">pop()</code> 연산이 O(1)이므로 전체 시간 복잡도는 <strong>O(NM)</strong>이 됩니다.</li>
</ul>

<h2 id="코드">코드</h2>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">sys</span>
<span class="nb">input</span> <span class="o">=</span> <span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span>
<span class="n">og_str</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">input</span><span class="p">().</span><span class="n">rstrip</span><span class="p">()]</span>
<span class="n">explosive_str</span> <span class="o">=</span> <span class="nb">input</span><span class="p">().</span><span class="n">rstrip</span><span class="p">()</span>

<span class="n">token_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">explosive_str</span><span class="p">)</span>

<span class="n">parsed_str</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">og_str</span><span class="p">)):</span>
    <span class="n">parsed_str</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">og_str</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="k">if</span> <span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">parsed_str</span><span class="p">[</span><span class="o">-</span><span class="n">token_len</span><span class="p">:])</span> <span class="o">==</span> <span class="n">explosive_str</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">token_len</span><span class="p">):</span>
            <span class="n">parsed_str</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>

<span class="k">if</span> <span class="n">parsed_str</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">parsed_str</span><span class="p">))</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s">'FRULA'</span><span class="p">)</span>
</code></pre></div></div>]]></content><author><name>Sangmyeong Lee</name></author><category term="PS" /><category term="stack" /><summary type="html"><![CDATA[백준 9935 - 문자열 폭발 문제 설명]]></summary></entry><entry><title type="html">[KR] 백준 33527 - 신촌 길찾기 서비스</title><link href="https://smyeong123.github.io/2025/01/02/33527-solution.html" rel="alternate" type="text/html" title="[KR] 백준 33527 - 신촌 길찾기 서비스" /><published>2025-01-02T00:00:00+00:00</published><updated>2025-01-02T00:00:00+00:00</updated><id>https://smyeong123.github.io/2025/01/02/33527-solution</id><content type="html" xml:base="https://smyeong123.github.io/2025/01/02/33527-solution.html"><![CDATA[<h1 id="백준-33527---신촌-길찾기-서비스">백준 33527 - 신촌 길찾기 서비스</h1>
<blockquote>
  <p>해당 문제는 BFS로 접근했다가 실패해 Floyd-Warshall 기법으로 푼 문제입니다.</p>
</blockquote>

<h2 id="문제-설명"><strong>문제 설명</strong></h2>
<p>5개의 대학교에 \(N\)개의 버스 정류장이 있으며, 각 대학교는 자체적으로 \(X\)개의 버스 노선을 운영합니다.<br />
서로 다른 대학교에서 운영하는 동일한 번호의 버스 노선은 <strong>서로 다른 노선</strong>이므로, <strong>총 \(5X\)개의 고유한 버스 노선이 존재</strong>합니다.</p>

<hr />

<h2 id="문제-풀이"><strong>문제 풀이</strong></h2>
<p>초기에는 BFS를 사용하여 <strong>\(N \times N\) 크기의 버스 노선 정보를 기반으로 탐색</strong>하는 방식을 시도했습니다.<br />
그러나 \(N\)의 최대 크기가 \(100,000\)으로 매우 크기 때문에, 이 방식은 <strong>비효율적이며 시간 초과가 발생</strong>합니다.<br />
반면, \(X\)의 최대 크기는 \(100\)으로 상대적으로 작아, <strong>\(X\)를 기준으로 최적화하는 방법이 더 효율적</strong>임을 알 수 있습니다.</p>

<p>이를 해결하기 위해, <strong>각 대학교의 버스 노선을 고유하게 변환</strong>하여 처리하였습니다.<br />
\(new\_route\_number = route\_number + route\_index * X - 1\) 연산을 사용하여 <strong>각 대학교의 노선을 고유한 번호로 매핑</strong>했습니다.</p>

<h3 id="1-인접-행렬-초기화"><strong>1. 인접 행렬 초기화</strong></h3>
<p>\(5X \times 5X\) 크기의 2D <code class="language-plaintext highlighter-rouge">bus</code> 행렬을 생성하여,<br />
정류장 \(i\)에서 정류장 \(j\)로 이동할 때 필요한 <strong>최소 환승 횟수를 저장</strong>합니다.<br />
각 버스 노선에서 <strong>직접 연결된 정류장은 환승 없이 이동 가능</strong>하므로 <code class="language-plaintext highlighter-rouge">bus[i][j] = 1</code>로 설정합니다.</p>

<hr />

<h3 id="2-floyd-warshall-알고리즘-적용"><strong>2. Floyd-Warshall 알고리즘 적용</strong></h3>
<p>이제 <strong>Floyd-Warshall 알고리즘</strong>을 사용하여 <strong>모든 정류장 간 최소 환승 횟수를 계산</strong>합니다.<br />
점화식은 다음과 같습니다:
\(bus[i][j] = min(bus[i][j], bus[i][k] + bus[k][j])\)</p>

<p>여기서,</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">bus[i][j]</code> : 정류장 \(i\)에서 정류장 \(j\)까지의 최소 환승 횟수</li>
  <li><code class="language-plaintext highlighter-rouge">bus[i][k] + bus[k][j]</code> : 정류장 \(i\)에서 \(k\)를 거쳐 \(j\)로 가는 경우</li>
</ul>

<p>이 과정을 <strong>\(5X\)번 반복</strong>하여 <strong>모든 정류장 쌍 간의 최소 환승 횟수를 계산</strong>합니다.</p>

<hr />

<h3 id="3-쿼리-처리"><strong>3. 쿼리 처리</strong></h3>
<p>Floyd-Warshall 알고리즘이 끝난 후,  질문 수 \(Q\)를 입력받고, 각 질문마다 <strong>출발 정류장 \(U_i\)와 도착 정류장 \(V_i\)</strong>를 받습니다.<br />
이미 구해둔 <code class="language-plaintext highlighter-rouge">bus</code> 행렬을 활용하여 <strong>\(U_i\)에서 \(V_i\)까지 가는 최소 환승 횟수를 찾고 출력</strong>합니다.</p>

<hr />

<h2 id="시간-복잡도-분석"><strong>시간 복잡도 분석</strong></h2>
<p>Floyd-Warshall 알고리즘의 시간 복잡도는 <strong>\(O(V^3)\)</strong>이며,<br />
여기서 \(V = 5X\)이므로 전체 시간 복잡도는:  \(O(5X^3) = O(X^3)\)
따라서, <strong>\(N\)이 커도 \(X\)가 작기 때문에 충분히 효율적인 방식</strong>입니다.</p>

<h2 id="코드">코드</h2>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">sys</span>
<span class="nb">input</span> <span class="o">=</span> <span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span>

<span class="n">N</span><span class="p">,</span> <span class="n">X</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">input</span><span class="p">().</span><span class="n">split</span><span class="p">())</span>
<span class="n">routes</span> <span class="o">=</span> <span class="p">[[</span><span class="n">r</span> <span class="o">+</span> <span class="n">j</span> <span class="o">*</span> <span class="n">X</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">input</span><span class="p">().</span><span class="n">split</span><span class="p">()))]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)]</span>
<span class="n">sz</span><span class="p">,</span> <span class="n">INF</span> <span class="o">=</span> <span class="mi">5</span><span class="o">*</span><span class="n">X</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="s">'inf'</span><span class="p">)</span>
<span class="n">bus</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span> <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span> <span class="k">else</span> <span class="n">INF</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sz</span><span class="p">)]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sz</span><span class="p">)]</span>

<span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">routes</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">r</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">r</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">:</span>
                <span class="n">bus</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="c1"># Floyd-Warshall Algorithm
</span><span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sz</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sz</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">bus</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">INF</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sz</span><span class="p">):</span>
                <span class="n">bus</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">bus</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="n">bus</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">bus</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">])</span>

<span class="n">Q</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span>
<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Q</span><span class="p">):</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">y</span><span class="p">:</span> <span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">input</span><span class="p">().</span><span class="n">split</span><span class="p">()))</span>
    <span class="n">res</span> <span class="o">=</span> <span class="nb">min</span><span class="p">((</span><span class="n">bus</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">routes</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">routes</span><span class="p">[</span><span class="n">v</span><span class="p">]),</span> <span class="n">default</span><span class="o">=</span><span class="n">INF</span><span class="p">)</span>
    <span class="n">sys</span><span class="p">.</span><span class="n">stdout</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s">'</span><span class="si">{</span><span class="n">res</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">res</span> <span class="o">&lt;</span> <span class="n">INF</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span><span class="si">}</span><span class="se">\n</span><span class="s">'</span><span class="p">)</span>
</code></pre></div></div>]]></content><author><name>Sangmyeong Lee</name></author><category term="PS" /><category term="graph" /><category term="folyd-warshall" /><summary type="html"><![CDATA[백준 33527 - 신촌 길찾기 서비스 해당 문제는 BFS로 접근했다가 실패해 Floyd-Warshall 기법으로 푼 문제입니다.]]></summary></entry><entry><title type="html">[KR] Operating System Note</title><link href="https://smyeong123.github.io/2024/11/01/Operating-System.html" rel="alternate" type="text/html" title="[KR] Operating System Note" /><published>2024-11-01T00:00:00+00:00</published><updated>2024-11-01T00:00:00+00:00</updated><id>https://smyeong123.github.io/2024/11/01/Operating-System</id><content type="html" xml:base="https://smyeong123.github.io/2024/11/01/Operating-System.html"><![CDATA[<h1 id="operating-system-운영체제">Operating System (운영체제)</h1>

<h2 id="개요">개요</h2>

<p>Operating System (OS)는 사용자가 컴퓨터를 사용하기 위해 필요한 시스템 소프트웨어이다. OS는 컴퓨터의 HW와 SW의 자원을 관리해준다. 
OS는 오늘날 개발자가 알아야하는 필수 지식중 하나로 다음과 같은 아젠다로 복습을 할 수 있다.</p>
<details>
<summary>Agenda</summary>

- Kernel &amp; System Call
- Process vs Thread
- Scheduling
- Virtual memory
- Address Translation, Paging, Swapping
- Concurrency
File System, Crash Consistency
</details>

<h2 id="user-mode-사용자-모드">User Mode (사용자 모드)</h2>
<p>사용자 모드로 실행되는 프로그램은 시스템의 자원에 직접 접근을 할 수 없다.</p>

<h3 id="system-call-시스템-호출">System Call (시스템 호출)</h3>
<p>시스템 호출: 사용자 프로그램이 커널의 기능을 요청하는 인터페이스이다. 사용자 모드에서 커널 모드로 <em>전환</em>을 한다.
예시로 <code class="language-plaintext highlighter-rouge">read()</code>, <code class="language-plaintext highlighter-rouge">write()</code>, <code class="language-plaintext highlighter-rouge">fork()</code> 등이 있다.</p>

<h2 id="kernel-mode-커널-모드">Kernel Mode (커널 모드)</h2>
<p>OS의 커널이 실행되는 모드다. 시스템의 모든 자원에 대한 접근이 가능하다. 또한 하드웨어와 직접적으로 상호작용을 한다.</p>
<h2 id="kernel-커널">Kernel (커널)</h2>
<p>커널: OS의 핵심으로 하드웨어와 소프트웨어를 연결하는 인터페이스다.
커널은 프로세스 관리, 메모리 관리, 하드웨어 자원 제어, 시스템 호출 관리를 해준다.</p>

<h2 id="process-프로세스-vs-thread-스레드">Process (프로세스) vs Thread (스레드)</h2>
<p>프로세스와 쓰레드의 차이를 알기전에 프로그램에 대해서 다시 한 번 집고 넘어가겠다.</p>

<p>프로그램이은 실행 파일(executable file)로 실행을 하기전 까지는 저장 장치에 저장만 되어있는 상태이며,아직 메모리에 할당이 안되어 있는 <strong>정적</strong>인 상태다.</p>

<p>프로그램을 실행을 하면 정적인 상태에서 <strong>동적</strong>인 상태로 변환이 되며, 해당 파일은 컴퓨터 메모리에 올라가며 이 상태를 <strong>프로세스</strong>라고 한다. 더 간단하게 말하자면 실행중인 프로그램이라고 생각하면 된다. 이 프로세스를 좀 더 작은 단위로 나눠서 접근을 할려고 하면 이제 우리는 이걸 <strong>스레드</strong>라고 한다.</p>

<p><img src="/public/media/processes.png" alt="processes" /></p>

<h3 id="프로세스"><strong>프로세스</strong></h3>
<p>프로세스는 OS로 부터 할당 받은 독립적인 실행 단위로, 프로그램이 실행 중인 상태를 나타낸다.</p>

<p>커널 안에 있는 무수히 많은 요소 중에서 프로세스를 관리하기 위해 관련 정보를 저장하는 집합이 있는데 PCB이다.</p>
<h4 id="process-control-block-pcb">Process Control Block (PCB)</h4>
<p>PCB는 프로세스 상태 및 정보를 저장하는 자료구조를 뜻한다. 프로세스는 OS로부터 스케줄링 알고리즘을 이용해 CPU의 사용량을 할당 받는다. 프로세스를 실행 중에 Context Switching 이 발생하면 현제 상태를 저장하고 CPU를 반환해야 한다. 그리고 나중에 다시 실행 됬을때 이전 상태를 불러온다. 그 정보가 저장되는 곳이 PCB이다.</p>

<p>PCB 에는 다음과 같은 정보가 저장된다.</p>
<ol>
  <li>PID (프로세스 아이디) : 고유한 프로세스 아이디이다.</li>
  <li>
    <p>Process State (프로세스 상태) :</p>

    <table>
      <thead>
        <tr>
          <th>상태</th>
          <th>설명</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>New</td>
          <td>프로세스가 막 생성된 상태</td>
        </tr>
        <tr>
          <td>Ready</td>
          <td>프로세스가 CPU에 실행되기 위해 대기하는 상</td>
        </tr>
        <tr>
          <td>Running</td>
          <td>프로세스가 작동이 되는 상태</td>
        </tr>
        <tr>
          <td>Waiting</td>
          <td>프로세스가 특정 이벤트를 기다리는 상태</td>
        </tr>
        <tr>
          <td>Terminated</td>
          <td>프로세스가 실행은 완료한 상태</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>Program Counter (프로그램 카운터) : 프로세스가 다음에 실행할 명령어의 주소를 가르키는 리지스터이다.</li>
  <li>CPU Register : CPU가 빠르게 접근할 수 있는 임시 저장소로,프로세스가 중단되었다가 다시 실행될떄를 위한 값을 저장한다.</li>
  <li>Scheduling Information: Process 우선순위, 스케줄링 관련 정보 저장한다.</li>
  <li>Memory Pointer : 메모리 영역을 가르키는 포인터다. 각 프로세스는 메모리가 Code Segment, Data Segment, Heap Segment, Stack Segment로 이루어져 있다.
    <ol>
      <li>Code Segment : 프로세스가 실행하는 코드가 기계어로 저장된 공간이다.</li>
      <li>Data Segement : Global Variable, Static Variable등이 저장되어 있는 공간이며 실행 중에 변경이 가능하다.</li>
      <li>Heap Segment : 사용자가 관리하는 영역으로 동적으로 할당한 메모리가 저장되는 공간이다.</li>
      <li>Stack Segment: 함수안에 저장이 된 Local Variable, Parameter, Return Value, Return Address등이 저장된 공간이다. 스택 자료구조 처럼 LIFO 방식으로 작동이 되며 빈 스택은 제거한다.</li>
    </ol>
  </li>
  <li>Memmory Management Information: 프로세스 주소 정보를 저장한다. <strong>Page Table</strong>, <strong>Segment Table</strong> 등이 포함된다.</li>
  <li>I/O Status Information : 프로세스 실행 중 발생하는 입출력 요청관련 정보를 저장한다.</li>
  <li>Account Information : <strong>프로세서</strong>의 사용 시간, 시간 제한 등 실행 정보가 저장된다.</li>
</ol>

<h4 id="ipc-inter-process-communication">IPC (Inter-Process Communication)</h4>
<p>IPC는 여러 프로세스 사이에서 서로 데이터를 주고 받는 행위를 뜻한다. 주로 파이프로 소통이 가능하며 메세지를 전달하고 받을 수 있다. 주로 <code class="language-plaintext highlighter-rouge">read()</code>와 <code class="language-plaintext highlighter-rouge">write()</code>를 이용을 한다.</p>

<p>예제 코드:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">write_pipe</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="n">Trader</span> <span class="o">*</span><span class="n">trader</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">perror</span><span class="p">(</span><span class="s">"FD is invalid</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">trader</span> <span class="o">-&gt;</span> <span class="n">is_online</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// DISCONNECTED_PID = trader -&gt; pid;</span>
			<span class="n">write</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">msg</span><span class="p">));</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="스레드"><strong>스레드</strong></h3>
<p>스레드는 프로세스 내부의 작은 실행 단위로, 프로세스 내 자원을 공유를 한다. 즉 같은 프로세스 안에 있는 여러 쓰레드는 메모리 영역을 공유 할 수 있다. 그리고 여러작업을 동시에 실행할 수 있도록 지원을 한다.</p>

<h2 id="multi-processing-vs-multi-threading">Multi-Processing vs Multi-Threading</h2>
<p><strong>멀티 프로세싱</strong>은 한개 이상의 프로세스가 실행되는 시스템이다.</p>

<p><strong>장점</strong>:</p>
<ul>
  <li>실행 중에 한 프로세스가 죽어도 다른 프로세스에 영향을 끼치지 않고 계속 실행</li>
</ul>

<p><strong>단점</strong>:</p>
<ul>
  <li>멀티 스레딩보다 많은 메모리 공간 (각 프로세스 당 독립적인 메모리 공간 차지)과 CPU 시간을 차지</li>
</ul>

<p><strong>멀티 스레딩</strong>은 한 프로세스에서 여러 개의 스레드를 동시에 실행하는 것이다.</p>

<p><strong>장점</strong>:</p>
<ul>
  <li>여러 스레드를 동시에 실행함으로서 프로그램이 효율적으로 자원을 공유하고, 활용</li>
  <li>스레드 간의 Context Switching은 같은 프로세스 내에서 Heap을 공유하므로, 프로세스 간의 Context Switching보다 더 빠르고 가벼움</li>
</ul>

<p><strong>단점</strong>:</p>
<ul>
  <li>하나의 스레드에 문제가 발생하면 전체 스레드에 영향을 받음</li>
  <li>다수의 스레드가 공유 데이터에 접근할 경우에 동기화 기법이 필수</li>
</ul>

<h3 id="context-switching-문맥-전환">Context Switching (문맥 전환)</h3>
<p>문맥 전환은 현재 실행하던 작업을 <strong>저장</strong>하고 다른 작업을 수행하기 위한 과정이다.</p>
<h3 id="scheduling-스케줄링">Scheduling (스케줄링)</h3>
<p>스케줄링: CPU 자원을 프로세스/쓰레드에 할당하는 전략이다.</p>
<h3 id="스케줄링-알고리즘">스케줄링 알고리즘</h3>
<ul>
  <li>FCFS(First Come First Served) : 요청된 순서대로 프로세스를 실행하지만 긴 프로세스가 짧은 프로세스를 지연한다.</li>
  <li>Round Robin : 할당량을 정하고 : 정해진 시간만큼 하당한 후 각 프로세스를 실행하며, 응답 시간이 동일하지만 문맥 전환 비용이 발생한다.</li>
  <li>SJF(Shortest Job First) : 실행 기간이 짧은 프로세스를 먼저 실행하며 평균 대기 시간을 최소화하지만, 실행 중에 인터럽트가 불가능하다.</li>
  <li>Priority Scheduling : 우선 순위가 높은 프로세스부터 실행을 하며, 운선 순위에 밀려나가 프로세스는 실행이 안 될 가능성이 있다.
    <h3 id="interrupt-인터럽트">Interrupt (인터럽트)</h3>
    <p>인터럽트는 CPU의 현재 작업을 중단하고 우선 순위가 높은 작업을 처리하도록 주는 신호다.</p>
  </li>
</ul>

<p>인터럽트 처리 과정은 다음과 같다.</p>
<ol>
  <li>인터럽트 발생</li>
  <li>언터럽트 서비스 루틴 실행 : 인터럽트 발생 시 실행되는 코드</li>
  <li>인터럽트 처리</li>
  <li>원래 작업으로 복귀</li>
</ol>

<h3 id="process-synchronization-동기화">Process Synchronization (동기화)</h3>
<p>주요 문제: Race condition(경쟁 상태), Deadlock(교착 상태), Starvation(기아 상태).</p>

<p>Lock: 상호 배제(mutual exclusion)을 보장.</p>

<p>Conditional Variable: 특정 조건을 만족할 때까지 쓰레드를 대기시키는 동기화 도구.</p>
<h4 id="concurrency-동시성-vs-parallelism-병렬성">Concurrency (동시성) vs Parallelism (병렬성)</h4>
<ul>
  <li>concurrency : 여러 작업이 동시에 처리</li>
  <li>Parallelism : 어떤 하나의 작업을 여러개로 나눈후, 이를 동시에 처리해서 완성하는 개념</li>
</ul>

<h4 id="race-condition-경쟁-상태">Race Condition (경쟁 상태)</h4>
<p>레이스 컨티션은 두개 이상의 스레드가 공유 자원을 읽고 수정하면서 시간에 따라 다른 출력을 나타내는 상황이다.</p>
<h4 id="critical-section-임계-구역">Critical Section (임계 구역)</h4>
<p>임계 구역은 두개 이상의 프로세스를 실행할때 동일한 자원을 동시에 접근하는 작업을 실행하는 코드 구간이다.</p>
<ol>
  <li>Mutual Exclusion</li>
  <li>Progress</li>
  <li>Bounded Waiting</li>
</ol>

<h4 id="solution">Solution</h4>
<ul>
  <li>Hardware
    <ol>
      <li>Memory Barriers</li>
      <li>Compare &amp; Swap</li>
      <li>Atomic Variables</li>
    </ol>
  </li>
  <li>Software
    <ol>
      <li>Mutex Locks</li>
      <li>Semaphores</li>
      <li>Monitor</li>
    </ol>
  </li>
</ul>

<h2 id="memory-management-메모리-관리">Memory Management (메모리 관리)</h2>

<p><a href="#process-control-block-pcb">PCB</a>에 설명한대로 메모리는 Code, Data, Heap, Stack 구간으로 나뉘어 질 수 있다.</p>

<p><img src="/public/media/memory%20structure.png" alt="memory structure" /></p>

<h2 id="virtual-memory-가상-메모리">Virtual Memory (가상 메모리)</h2>
<p>Virtual Memory: 실제 물리적 메모리보다 큰 논리적 주소 공간을 제공 한다.</p>

<p>장점:</p>
<ul>
  <li>큰 프로그램 실행 가능</li>
  <li>메모리 효율적 사용</li>
</ul>

<!-- ### Address Translation (주소 변환)
주소 변환은 가상 주소를 물리 주소로 변환하는 과정이다. 
주로 MMU(Memory Management Unit)가 수행을 하며,....  -->

<h3 id="paging-페이징">Paging (페이징)</h3>
<p>페이징은 가상 주소 공간을 고정 크기 단위인 페이지로 나누고, 물리적 주소를 페이지 프레임으로 나눠서 매핑하는걸 의미한다. 이떄 페이지 테이블을 이용해서 가상 메모리를 관리를 해준다.</p>

<p>사용되는 알고리즘: FIFO, LRU(Least Recently Used), Optimal.</p>

<ul>
  <li>메모리 보호</li>
  <li>페이징 테이블</li>
  <li>접근 권한</li>
</ul>

<h3 id="swapping-스와핑">Swapping (스와핑)</h3>
<p>스와핑은 물리 메모리 부족 시, 일부 페이지를 디스크로 이동하는 행위를 일컫는다.</p>

<p><strong>Page Fault</strong> (페이지 폴트): 필요한 페이지가 메모리에 없을 때 발생한다.</p>

<!-- ## Cache (캐시)

--- -->
<h2 id="기타">기타</h2>

<h3 id="redundant-array-of-independent-raid">Redundant Array of Independent (RAID)</h3>
<p>RAID는 여러개의 하드디스크가 있을때 동일한 데이터를 다른 위치에 중복해서 저장하는 방법이다. 이는 <strong>데이터 복구</strong>를 위해 자주 쓰는 방법이다.</p>

<!-- 
#### Stripping & Mirroring (스트라이핑 및 미러링) 
- 스트라이핑 : 
- 미러링 :  -->

<h2 id="references">References</h2>
<ul>
  <li><a href="https://pages.cs.wisc.edu/~remzi/OSTEP/">Operating Systems: Three Easy Pieces</a></li>
  <li><a href="https://medium.com/@jamesypatch/multithreading-vs-hyperthreading-benefits-and-drawbacks-e82970686426">Multi-Threading vs Multi-Processing</a></li>
  <li><a href="https://velog.io/@hyungzin0309/User-mode-Kernel-mode">User mode, Kernel Mode</a></li>
  <li><a href="https://velog.io/@shindoyeon/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B5%AC%EC%A1%B0">메모리 구조</a></li>
  <li><a href="https://velog.io/@raejoonee/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EC%8A%A4%EB%A0%88%EB%93%9C%EC%9D%98-%EC%B0%A8%EC%9D%B4">프로세스와 스레드 차이</a></li>
  <li><a href="https://velog.io/@mingadinga_1234/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EB%9E%80-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%9D%98-%EC%83%81%ED%83%9C">프로세스 상태</a></li>
  <li><a href="https://liamkwo.github.io/interview1/">신입 백앤드 개발자(나)를 위한 면접 질문 정리 - 네트워크, 운영체제</a></li>
</ul>]]></content><author><name>Sangmyeong Lee</name></author><category term="CS" /><category term="OS" /><summary type="html"><![CDATA[Operating System (운영체제)]]></summary></entry></feed>